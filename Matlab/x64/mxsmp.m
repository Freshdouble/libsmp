function [methodinfo,structs,enuminfo,ThunkLibName]=mxsmp
%MXSMP Create structures to define interfaces found in 'libsmp_x64'.

%This function was generated by loadlibrary.m parser version  on Tue Apr 11 01:09:53 2017
%perl options:'libsmp_x64.i -outfile=mxsmp.m -thunkfile=libsmp_x64_thunk_pcwin64.c -header=libsmp_x64.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'libsmp_x64_thunk_pcwin64');
%  void libsmp_addReceivedBytes ( const uint8_t * bytes , uint32_t length , void * obj ); 
fcns.thunkname{fcnNum}='voidvoidPtruint32voidPtrThunk';fcns.name{fcnNum}='libsmp_addReceivedBytes'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'uint8Ptr', 'uint32', 'voidPtr'};fcnNum=fcnNum+1;
%  size_t libsmp_bytesMessagesToReceive ( void * obj ); 
fcns.thunkname{fcnNum}='uint64voidPtrThunk';fcns.name{fcnNum}='libsmp_bytesMessagesToReceive'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint64'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  uint16_t libsmp_getNextReceivedMessageLength ( void * obj ); 
fcns.thunkname{fcnNum}='uint16voidPtrThunk';fcns.name{fcnNum}='libsmp_getNextReceivedMessageLength'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint16'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  uint8_t libsmp_getReceivedMessage ( message_t * msg , void * obj ); 
fcns.thunkname{fcnNum}='uint8voidPtrvoidPtrThunk';fcns.name{fcnNum}='libsmp_getReceivedMessage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint8'; fcns.RHS{fcnNum}={'message_tPtr', 'voidPtr'};fcnNum=fcnNum+1;
%  size_t libsmp_getMessagesToSend ( void * obj ); 
fcns.thunkname{fcnNum}='uint64voidPtrThunk';fcns.name{fcnNum}='libsmp_getMessagesToSend'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint64'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  uint16_t libsmp_getNextMessageLength ( void * obj ); 
fcns.thunkname{fcnNum}='uint16voidPtrThunk';fcns.name{fcnNum}='libsmp_getNextMessageLength'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint16'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  uint8_t libsmp_getMessage ( message_t * msg , void * obj ); 
fcns.thunkname{fcnNum}='uint8voidPtrvoidPtrThunk';fcns.name{fcnNum}='libsmp_getMessage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint8'; fcns.RHS{fcnNum}={'message_tPtr', 'voidPtr'};fcnNum=fcnNum+1;
%  uint32_t libsmp_sendBytes ( const uint8_t * bytes , uint32_t length , void * obj ); 
fcns.thunkname{fcnNum}='uint32voidPtruint32voidPtrThunk';fcns.name{fcnNum}='libsmp_sendBytes'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'uint8Ptr', 'uint32', 'voidPtr'};fcnNum=fcnNum+1;
%  void * libsmp_createNewObject ( bool useRS ); 
fcns.thunkname{fcnNum}='voidPtrboolThunk';fcns.name{fcnNum}='libsmp_createNewObject'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='voidPtr'; fcns.RHS{fcnNum}={'bool'};fcnNum=fcnNum+1;
%  void libsmp_deleteObject ( void * obj ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='libsmp_deleteObject'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
structs.message_t.members=struct('message', 'uint8#65536', 'size', 'uint32');
methodinfo=fcns;